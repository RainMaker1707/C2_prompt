## Introduction
This file contains the documentation of the Simple Command and Control (C2) framework.
The framework will be referenced as Simple on the following documentation.
A C2 framework is generally designed to use pre-installed executable implants that create a backdoor in the infected device.
To achieve this goal Simple uses the HTTP and HTTPS protocols to handle communication between the master and the slave devices.
 
 
## Implants
Implants are executables generated by the C2 framework to create the backdoor.
In the case of Simple, the implants are simple Python HTTP or HTTPS servers that are predetermined and not generated by the framework.
These servers will be in charge to handle communication and execute actions when ordered by the master device.
These implants should also send heartbeat messages to the master.
 
 
## Requests
To handle communication Simple needs formatted requests that help the server identify the action it needs to take.
For example, the Sliver framework uses file extensions to identify actions and parameters to send data (i.e. .png = close communication).
Simple uses this format:
 - `/images/{randomFileName}.png` create connection (slave received this => master online)
 - `/pictures/{randomFileName}.png` close connection (slave receiving this will kill their own process)
 - `/source/{randomFileName}.html` prepare a listener (slave received this => master now using it) 
 - `/styles/{randomFileName}.css` pause the connection (slave receiving this will stop listener but stay online)
 - `/source/{randomFileName}.html?val={valueToCarryData}` send a predetermined order in server function of value
 - `/scripts/{taskName}.js` run a specific predetermined task in server function of `taskName` (could use parameter)
 - `/scripts/checkPass.js`run an SSH connection with the slave
 
For heartbeat messages we will use a UDP message with an interval under the lost connection time.
The randomFileName will be generated from a dictionary file shared by both the master and slave server.
 
 
## Usage
1. Install the implant on a slave device (here you will just need to install Python and the required module).
2. Run the implant on the slave device (`python3 implant.py`).
3. Run the server on the master device (`python3 server.py`).
4. Use `/help` to get a list of available commands.
5. Use the command you want in the master server interface.
 
 
## Detection
If we have access to the dictionaries that are used, it will be easier to create a regular expression that can identify these kind of queries in HTTP.
For example, if the dictionaries are 
 - `randomfileName = ["home", "shop"]` 
 - `taskName = ["task1", "task2"]`
The exact dictionnaries are not available at the moment.
 
We can easily make the following regular expressions:
 - `((\/styles\/)|(\/source\/)|(\/script\/)){1}((home)|(shop)){1}((\.png)|(\.html)|(\.css)|(\.js)){1}`

    This regular expression will match all queries made with the `randomFileName` dictionary, but not match their parameter (we can add `(\?{1}.+=.+)?(\&.*)?` to the regular expression to match all arguments with the current match).

 - `(\/script\/){1}((checkPass)|(task1)|(task2)){1}(\.js){1}`

   This regular expression will match all queries made with the `taskName` dictionary. Again, if you want to match arguments with the current pattern, add the little regular expression above.

So, there is only one part in each regular expression that needs to be changed. It can be written as 

 ```python
 group = "("
 for e in dic:
     group += "("+e+")|
 group[-1] = ")" # replace last | by )
 ```

With these two regular expressions we should be able to handle all queries from the master server to the slave server in HTTP, but we will not detect heartbeat messages.

If we do not have access to the dictionaries, it will be more difficult to detect it accurately but we can use `(.+)` instead of the dictionary group part to match any sequence of characters of any length.