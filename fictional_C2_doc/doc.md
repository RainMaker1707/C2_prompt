# Fictional C2 documentation


## Introduction
This file contains the documentation of a fictional Command and Control (C2) framework.
A C2 framework is generally designed to use pre-installed executable implants that create a backdoor in the infected device.
To achieve this goal our fictionnal C2 framework will use HTTP and HTTPS protocol to handle communication between the master and the slave devices.


## Implants
Implants are executable generated by the C2 framework to create the backdoor.
In our case it will be simple python HTTP or HTTPS servers that are predetermined and not generated by the framework.
These server will be in charge to handle communication and make action when ordered by the master device.
These server should also send alive message to the master.


## Requests
To handle communication we need formatted requests that help the server identify action to take.
For example Sliver framework uses file extension to identify action and parameter to send data (i.e. .png = close communication).
In our example we will use this format.
- `/images/{randomFileName}.png` create connection (slave received this => master online)
- `/pictures/{randomFileName}.png` close connection (slave receiving this will kill their own process)
- `/source/{randomFileName}.html` prepare listener (slave received this => master now using it) 
- `/styles/{randomFileName}.css` pause connection (slave receiving this will stop listener but stay online)
- `/source/{randomFileName}.html?val={valueToCarryData}` send predetermined order in server function of value
- `/scripts/{taskName}.js` run specific predetermined task in server function of taskName (could use parameter)
- `/scripts/checkPass.js`run an ssh connection with the slave

For alive message we will use a UDP message with interval under the lost connection time.
The randomFileName will be generated from a dictionnary file shared by both master and slave server.


## Usage
1. Install implant on slave device (here you will just need to install python and required module)
2. Run the implant on slave device (python3 implant.py)
3. Run the server on master device (python3 server.py)
4. Use /help to get a list of available command
5. Use the command you want in the master server interface


## Detection
If we have access to the dictionnaries used it will be easier to make regex that can identify these kind of query in HTTP.

For example if the dictionnaries are 
- randomfileName = ["home", "shop"] 
- taskName = ["task1", "task2"]
We can easily make these regex:
- `((\/styles\/)|(\/source\/)|(\/script\/)){1}((home)|(shop)){1}((\.png)|(\.html)|(\.css)|(\.js)){1}`
This regex will match all queries made with randomFileName dictionnary but not match there parameter (we can add `(\?{1}.+=.+)?(\&.*)?` to the actual regex to match all arguments with the current match)
- `(\/script\/){1}((checkPass)|(task1)|(task2)){1}(\.js){1}`
This regex will match all queries made with taskName dictionnary. Again if you want to match arguments with the current pattern add the little regex above.

So there is only one part in each regex that need to be changed.
It can be written as 
```python
group = "("
for e in dic:
    group += "("+e+")|
group[-1] = ")" # replace last | by )
```
With these two regex we should be able to handle all queries from master server to slave server in HTTP, but we will not detect alive message.

If we do not have access to the dictionnaries it will be more difficult to detect it accuratly but we can use 
`(.+)` instead of the dictionnary group part to match any sequence of characters of any length.